---
title: "Projekt do předmětu Časové řady I"
author: "Michal Červenka, Martin Heger, Štěpán Husa"
date: "2025-12-15"
lang: cs
format:
  html:
    theme: default
    toc: true
    toc-depth: 3
    toc-title: "Obsah"
    code-fold: true
code-tools: true
embed-resources: true
fig-cap: true
execute:
  echo: true
  warning: false
  message: false
---

# Úvod

## 1. Načtení knihoven

```{r}
#| label: knihovny
#| echo: true

# Načtení potřebných balíčků
if (!require(forecast)) install.packages("forecast", repos = "https://cloud.r-project.org")
if (!require(zoo)) install.packages("zoo")
if (!require(readr)) install.packages("readr", repos = "https://cloud.r-project.org")
if (!require(tseries)) install.packages("tseries", repos = "https://cloud.r-project.org")
library(readr)
library(zoo)
library(forecast)
library(tseries)
library(ggplot2)
library(dplyr)
library(tseries)
```

## 2. Načtení dat

```{r}
#| label: data
#| echo: true

# Načtení datasetu
data <- read_csv("MLTollsStackOverflow.csv")
head(data[c("month", "python", "r")])
```

## 3. Popis dat

Použitý dataset obsahuje měsíční počty dotazů na StackOverflow od roku 2009 do roku 2020 pro různé programovací knihovny a technologie. Pro účely této analýzy se zaměřujeme pouze na dvě proměnné – Python a R, které reprezentují počet dotazů souvisejících s těmito jazyky v jednotlivých měsících.

Nejprve jsme si zobrazili několik prvních pozorování datasetu, abychom se seznámili se strukturou dat a ověřili, že hodnoty odpovídají očekávanému formátu. Následně jsme vypočítali základní popisné statistiky pro obě časové řady.

### Popisné statistiky - Python & R

```{r}
#| label: popis-dat
#| echo: true

# Popisné statistiky
summary(data[, c("python", "r")])
```

-   Minimální počet dotazů je výrazně vyšší u Pythonu než u R.
-   Medián i průměr jsou u Pythonu několikanásobně vyšší než u R, což naznačuje dlouhodobě větší popularitu Pythonu.
-   Rozptyl hodnot je u Pythonu rovněž vyšší, což souvisí s rychlejším růstem zájmu v čase.
-   Maximální hodnoty ukazují, že Python dosahuje až téměř 24 000 dotazů za měsíc, zatímco R přibližně 5 100.

------------------------------------------------------------------------

# Analýza

## 1. Předběžný výzkum časové řady

### Grafické zobrazení časových řad

#### Python

```{r}
#| label: vyzkum
#| echo: true

# Vytvoření časové řady: Python
python_ts <- ts(data$python,
                start = c(2009, 1),
                #end = c(2015, 12),
                frequency = 12)

# Vytvoření časové řady: R
r_ts <- ts(data$r,
           start = c(2009, 1),
           #end = c(2015, 12),
           frequency = 12)

# Graf: Python
plot(python_ts,
     main = "StackOverflow: dotazy k Pythonu",
     ylab = "počet dotazů za měsíc",
     xlab = "rok")
```

-   Jasný rostoucí trend od roku 2009 do 2020.
-   Postupem času narůstá i variabilita počtu dotazů.
-   Viditelné pravidelné sezónní kolísání.

#### R

```{r}
#| label: vyzkum_R
#| echo: true
# Graf: R
plot(r_ts,
     main = "StackOverflow: dotazy k R",
     ylab = "počet dotazů za měsíc",
     xlab = "rok")
```

-   Trend také roste, ale pomaleji a méně výrazně než u Pythonu.
-   Amplituda sezónnosti je menší.
-   Po roce 2017 se růst zpomaluje.

#### Společný graf

```{r}
#| label: vyzkum_spolecny
#| echo: true

# Společný graf
par(mfrow = c(1,1))


ts.plot(cbind(python_ts, r_ts),
        col = c("blue", "red"),
        lty = 1:2,
        main = "Python vs R",
        ylab = "Počet dotazů za měsíc")

legend("topleft",
       legend = c("Python", "R"),
       col = c("blue", "red"),
       lty = 1:2,
       bty = "n")
```

-   Python má výrazně větší počet dotazů a rychleji roste.
-   Od roku \~2014 se rozdíl ještě zvětšuje.
-   Oba jazyky mají podobný vzor sezónnosti.

### Aditivní dekompozice

#### Python

```{r}
#| label: vyzkum_3
#| echo: true

# Additivní dekompozice

## Python
decomp_python <- decompose(python_ts, type = "additive")
plot(decomp_python)
```

-   **Trend**: silně rostoucí, plynulý.
-   **Sezónnost**: pravidelná, opakující se ročně.
-   **Remainder**: náhodné fluktuace bez jasné struktury.


## 2. Testování stacionarity

### Python

```{r}
#| label: stacionarita_python
#| echo: true
adf_python <- adf.test(python_ts)
adf_python
```

### Python - odmocina

```{r}
#| label: stacionarita_python_diff
#| echo: true
adf_python_diff <- adf.test(sqrt(python_ts))
adf_python_diff
```

### Python - odmocnina a diferencování

```{r}
#| label: stacionarita_r_diff
#| echo: true
adf_r_diff  <- adf.test(diff(sqrt(python_ts)))
adf_r_diff
```

**Shrnutí**:

-   Časová řada je nestacionární v původní podobě.
-   Důvodem je především rostoucí trend a možná sezónnost.
-   Časová řada se stává stacionární po jedné diferenci a odmocninové transformaci.
-   Pro modelování ARIMA bude nutné řady diferencovat (parametr d = 1).

## 3. Autokorelace a parciální autokorelace

### Python

```{r}
#| label: acf-pacf_python
#| echo: true

par(mfrow = c(2,2))

acf(sqrt(python_ts), main = "ACF – sqrt(Python)",lag.max = 36)
pacf(sqrt(python_ts), main = "PACF – sqrt(Python)",lag.max = 36)

acf(diff(sqrt(python_ts)), main = "ACF – diff(sqrt(Python))",lag.max = 36)
pacf(diff(python_ts), main = "PACF – diff(sqrt(Python))",lag.max = 36)
```

**Shrnutí**:

- exponenciální pokles acf, pacf nevýznamná po prvním lagu -> AR(1)
- řada je stacionární po první diferenci naznačuje ARIMA(1, 1, 0)


## 4. Výběr vhodných modelů

Na základě předchozí analýzy ACF a PACF a dekompozice řady přistupujeme k manuální konstrukci modelu. Zaměříme se přitom na časovou řadu dotazů na Python (R má velmi podobný průběh korelogramů). Nejprve však data logaritmujeme/odmocníme, abychom stabilizovali rostoucí rozptyl (heteroskedasticitu), který jsme pozorovali v grafické analýze.

```{r}
#| label: boxcoxlambda
#| echo: true
print("boxcox lambda")
BoxCox.lambda(python_ts)
```

```{r}
python_log<-sqrt(python_ts)
```

```{r}
#| label: acf-pacf_python1
#| echo: true

par(mfrow = c(1,2))

acf(python_log, main = "ACF – Python",lag.max = 36)
pacf(python_log, main = "PACF – Python",lag.max = 36)
```
```{r}
#| label: acf-pacf_python2
#| echo: true
par(mfrow = c(1,2))
acf(diff(python_log), main = "ACF – diff(Python)",lag.max = 36)
pacf(diff(python_log), main = "PACF – diff(Python)",lag.max = 36)
```
```{r}
#| label: acf-pacf_python3
#| echo: true

par(mfrow = c(1,2))
acf(diff(diff(python_log),lag=12), main = "ACF – diff(Python)",lag.max = 48)
pacf(diff(diff(python_log),lag=12), main = "PACF – diff(Python)",lag.max = 48)
```

**Odůvodnění volby parametrů modelu SARIMA**

Na základě vizuální analýzy ACF a PACF odmocněné řady, zdiferencované řady, sezoně zdiferencované řady a předchozí dekompozice jsme stanovili parametry pro výchozí model ve tvaru $SARIMA(p,d,q)(P,D,Q)_{[12]}$.

-   Trend ($d=1$):

    Původní časová řada vykazovala jasný rostoucí trend a nestacionaritu, což potvrdil i Augmented Dickey-Fullerův test (p-hodnota $< 0.05$ po diferenciaci). Aplikace první diference tento trend úspěšně odstranila. Graf ACF diferencované řady navíc ukazuje na lagu 1 a 2 významné záporné hodnoty, což je v literatuře považováno za varovný signál proti dalšímu diferencování (riziko tzv. over-differencing). Z tohoto důvodu fixujeme řád diferenciace na $d=1$.

-   Sezónnost ($D=1$):

    Vzhledem k jasné roční cykličnosti a statisticky významné korelaci na lagu 12 s lineárním poklesem na dalších lazích v ACF diferencované řady je zřejmé, že řada obsahuje stochastickou sezónnost. Tu modelujeme zavedením sezónní diference ($D=1$) s periodou $s=12$.

-   Nesezónní struktura ($p=0, q=1$):

    -   MA část ($q=1$): Graf ACF vykazuje na lagu 13 statisticky významnou hodnotu. Tento vzor indikuje, že ač na lagu 1 není významná autokorelace, tak že MA část bude i tak potřeba. 

    -   AR část ($p=0$): Graf PACF nevykazuje na žádnách lazích statisticky významné hodnoty. Tento vzor indikuje, že AR část nebude potřeba.


-   Sezónní struktura ($P=0, Q=1$):

    Analýza sezónních lagů (12, 24, 36) odhalila poměrně nejasnou strukturu. Jak ACF tak i PACF vykazují na lagu 12 silnou zápornou autokorelaci a poté se na lazích 24 a dál odstřihnou. Při detailnějším pohledu však vidíme jasné ustřižení na ACF na lagu 24 a spíše pozvolné doznívání sezoních lazích u PACF. Zvolíme proto Q=1 a podrobíme model dalším testům. 

**Výsledný startovací model:** $SARIMA(0,1,1)(0,1,1)_{[12]}$

**Poznámka k riziku:** Jsme si vědomi hrozby redundance parametrů (tzv. *parameter cancellation*), která hrozí u takto specifikovaných smíšených modelů. Tento model slouží jako výchozí bod a v další fázi analýzy budeme testovat statistickou významnost jednotlivých koeficientů s cílem model zjednodušit (zejména v nesezónní části).

## 5. Optimalizace modelu

Nyní tento model odhadneme a provedeme testování statistické významnosti jeho koeficientů. Naším cílem je najít nejjednodušší možný model , proto zkontrolujeme, zda jsou všechny parametry skutečně potřeba.

```{r}
#| label: odhad-startovaci
#| echo: true

# Odhad modelu SARIMA(0,1,1)(0,1,1)[12]
# Volba q=2 vychází z pozorování ACF (lag 1, 2)
fit_manual <- Arima(python_log, 
                    order = c(0, 1, 1), 
                    seasonal = c(0, 1, 1))

print("=== ANALÝZA KOEFICIENTŮ (Startovací model) ===")
print(fit_manual)

# Test významnosti parametrů nového modelu
t_stat_d2 <- fit_manual$coef / sqrt(diag(fit_manual$var.coef))
print(data.frame(Koeficient = names(fit_manual$coef), 
                 t_statistika = t_stat_d2,
                 Vyznamny = abs(t_stat_d2) > 1.96))

checkresiduals(fit_manual)

```



### Redukce modelu na základě statistické významnosti

Analýza t-statistik odhadnutých koeficientů modelu $SARIMA(0,1,0)(1,1,1)_{[12]}$ odhalila prostor pro zjednodušení :

-   **Parametr MA(1):** T-statistika dosahuje hodnoty pouze **1.1**, což je pod kritickou hranicí 1.96.

-   **Parametr SMA(1):** Naopak sezónní MA člen je statisticky významný (t-statistika **-3.46**), což potvrzuje správnost naší identifikace sezónní složky.

V souladu s touto analýzou odstraňujeme nevýznamný parametr $ma1$ a definujeme náš finální manuální model ve tvaru $SARIMA(0,1,0)(0,1,1)_{[12]}$.



```{r}
#| label: final-manual-optimalized
#| echo: true

# Finální manuální model (po redukci nevýznamných parametrů)
# Odstraňujeme ma2 (q=2 -> q=1)
# Stále držíme d=2, protože to vyžaduje trend
fit_manual_final <- Arima(python_log, 
                          order = c(0, 1, 0), 
                          seasonal = c(0, 1,1 ))

print("=== FINÁLNÍ MANUÁLNÍ MODEL (0,1,0)(0,1,1) ===")
print(fit_manual_final)

# Finální kontrola reziduí
checkresiduals(fit_manual_final)
```

Vidíme, že graficky výsledek sice vypadá jako bílý šum, ale box test i korelogram ukazují, že se nám pomocí manuální analýzy nepodařilo nalézt model, jehož rezidua by byla čistým bílým šumem, oněco lépe vychází box test i AICc pro nový model s parametrem q=0. Proto tento model volíme jako náš finální . Dle našeho odborného posouzení se i přes nedostatky (např lag 13 významný) jedná o nejlepší možný manuální model.

Pro kontrolu správnosti našeho úsudku nyní necháme algoritmus `auto.arima` (který minimalizuje informační kritérium AICc), aby nalezl optimální model automaticky, a následně jej porovnáme.

```{r}
#| label: porovnani-auto
#| echo: true

# Automatický návrh (s důrazem na prohledání prostoru)
fit_auto <- auto.arima(python_log, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)

print("=== AUTO ARIMA NÁVRH ===")

print(fit_auto)
checkresiduals(fit_auto)
# Srovnání AICc
# Pozor: Porovnáváme náš finální manuální model (fit_manual_final) s automatem
srovnani <- data.frame(
  Model = c("Náš manuální (0,1,0)(0,1,1)", "Auto ARIMA návrh","Náš manuální (0,1,1)(0,1,1)"),
  AICc = c(fit_manual_final$aicc, fit_auto$aicc,fit_manual$aicc)
)
print(srovnani)
```

Algoritmus `auto.arima` identifikoval model, který dosahuje o 1 bod menšího  informačního kritéria (AICc). Box test  také zamítá hypotézu o nezávislých reziduích. Pro finální predikci přesto volíme náš manualní  model se statisticky nevýznamným horším AICc a dáváme přednost jeho jednoduchosti.

```{r}
#| label: final-model-select
#| echo: true
final_model <- fit_manual_final
```

## 6. Diagnostika modelu

Předtím, než model použijeme k predikci, musíme ověřit, zda jeho rezidua (chyby) splňují předpoklady "bílého šumu". Zkontrolujeme:

-   Zda rezidua nevykazují autokorelaci (podstatná informace nezůstala v datech).

-   Zda mají normální rozdělení.

```{r}
#| label: diagnostika
#| echo: true

# Grafická diagnostika
checkresiduals(final_model)


```

#### Vyhodnocení diagnostiky

Vidíme, že p-hodnota Ljung-Boxova testu je nižší než hladina významnosti $0.05$, a proto zamítáme nulovou hypotézu o nezávislosti reziduí. To znamená, že model nedokázal zachytit veškerou strukturu v datech. Ačkoliv rezidua nejsou dokonalým bílým šumem, vizuální kontrola a validace na testovacím vzorku ukazují, že model zachycuje hlavní dynamiku trendu a sezónnosti. Zbytková autokorelace je pravděpodobně způsobena strukturálním zlomem v popularitě Pythonu po roce 2017.

## 7. Predikce

Provedeme predikci na 12 měsíců dopředu. Je nutné provést zpětnou transformaci (omocnění), protože model pracoval s odmocninami.

```{r}
#| label: predikce
#| echo: true

# 1. Predikce v odmocnine
forecast_log <- forecast(final_model, h = 12)

# 2. Zpětná transformace (exp)
forecast_orig <- forecast_log
forecast_orig$mean  <- (forecast_log$mean)^2
forecast_orig$lower <- (forecast_log$lower)^2
forecast_orig$upper <- (forecast_log$upper)^2
forecast_orig$x     <- (forecast_log$x)^2

# 3. Vykreslení
autoplot(forecast_orig) +
  autolayer(forecast_orig$mean, series = "Predikce", size = 1) +
  labs(title = "Predikce poptávky po Pythonu (SARIMA)",
       y = "Počet dotazů",
       x = "Rok") +
  theme_minimal()

# Výpis hodnot
print(head(forecast_orig$mean, 12))
```

### Validace modelu – predikce posledních 24 měsíců

Kromě predikce do budoucna je užitečné ověřit, jak dobře model dokáže zpětně předpovědět známá data. Proto odstraníme posledních 24 měsíců z časové řady, na zbytku znovu natrénujeme SARIMA model a následně se pokusíme predikovat právě těchto 24 měsíců.

Tuto „pseudo-predikci“ poté porovnáme se skutečnými hodnotami. Pokud je model správně nastavený, měl by zachytit alespoň základní trend a sezónní průběh, i když krátkodobé výkyvy se mohou lišit.

```{r}
#| label: predikce_zpetna
#| echo: true

h <- 24  

n <- length(python_log)
python_log_train <- head(python_log, n - h)  
python_log_test  <- tail(python_log, h)      

# stejný typ modelu jako final_model, znovu odhadnutý na zkrácené řadě
model_train <- Arima(python_log_train, model = final_model)

# predikce posledníhch 2 let v odmocnine a zpětná transformace
forecast_log_oos  <- forecast(model_train, h = h)
forecast_oos_mean <- (forecast_log_oos$mean)^2

# graf: celá řada + predikce posledních 2 let
autoplot((python_log)^2) +
  autolayer(forecast_oos_mean, series = "Predikce posledních 2 let", size = 1) +
  labs(title = "Validace modelu – predikce posledních 2 let",
       y = "Počet dotazů",
       x = "Rok") +
  theme_minimal()
```

------------------------------------------------------------------------

# Závěr

V této práci jsme analyzovali vývoj popularity jazyka Python na StackOverflow. Zjistili jsme silný rostoucí trend a sezónnost. Pomocí odmocninové transformace a diferencování jsme data stacionarizovali. Manuální analýzou koeficientů a srovnáním s automatickou selekcí jsme identifikovali jako nejvhodnější model $SARIMA(0,1,0)(0,1,1)_{[12]}$. Tento model prošel diagnostickými testy a byl použit k predikci, která očekává další růst zájmu s typickými sezónními výkyvy.

## Diskuze

-   **Omezení modelu:** Hlavním limitem modelu je zamítnutí hypotézy o nezávislosti reziduí (Ljung-Boxův test). To naznačuje, že model nedokázal plně absorbovat veškerou strukturu dat, pravděpodobně v důsledku strukturálního zlomu v popularitě Pythonu kolem roku 2017 a přítomnosti heteroskedasticity (změny rozptylu), kterou odmocninová transformace odstranila jen částečně. Model je tedy vhodný pro bodovou predikci trendu, ale intervaly spolehlivosti mohou být mírně podhodnocené.
-   **Možnosti vylepšení:** Přesnost modelu by mohla být zvýšena zkrácením časové řady (např. použitím dat pouze od roku 2015), čímž by se eliminoval vliv staršího, odlišného chování trendu. Dále by bylo možné využít pokročilejší modely odolné vůči strukturálním zlomům, jako je např. Prophet, nebo zahrnout exogenní proměnné (např. počet pracovních dní v měsíci).

## Závěrečné poznámky

Projekt ukazuje postup od přípravy dat až po modelování a predikci pomocí metod ARIMA a jejich variant.


