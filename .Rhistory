# lineární trend + měsíční efekty
m_lin <- lm(y ~ time + month, data = df)
# Robustní (HAC/Newey-West) směrodatné chyby
coeftest(m_lin, vcov. = vcovHAC(m_lin))
data(retail, package = "TSA")
log_retail <- log(retail)
df <- data.frame(
time = as.numeric(time(log_retail)),
month = factor(cycle(log_retail), levels = 1:12),
y = as.numeric(log_retail)
)
# lineární trend + měsíční efekty
m_lin <- lm(y ~ time + month, data = df)
# -----------------------------------------------------------
# 2. Predikce na 24 měsíců dopředu
# -----------------------------------------------------------
h <- 24
t_last <- tail(df$time, 1)
m_last <- as.integer(tail(cycle(log_retail), 1))
t_future <- seq(from = t_last + 1/12, by = 1/12, length.out = h)
m_future <- ((m_last + seq_len(h) - 1) %% 12) + 1
newdat <- data.frame(
time = t_future,
month = factor(m_future, levels = 1:12)
)
# predikce (střední hodnota log-prodejů)
newdat$pred <- predict(m_lin, newdata = newdat)
# -----------------------------------------------------------
# 3. Fit z trénovacích dat a spojení do jednoho grafu
# -----------------------------------------------------------
df$fitted <- fitted(m_lin)
ggplot() +
# původní data
geom_line(data = df, aes(x = time, y = y), color = "grey40", linewidth = 0.7) +
# fitovaný trend (in-sample)
geom_line(data = df, aes(x = time, y = fitted), color = "blue", linewidth = 1) +
# predikce (out-of-sample)
geom_line(data = newdat, aes(x = time, y = pred), color = "red", linewidth = 1) +
labs(
title = "UK Retail Sales – log-transformace, lineární trend + sezónnost",
subtitle = "Modrá = fitted values, Červená = 24měsíční predikce",
x = "Rok", y = "log(Prodeje)"
) +
theme_minimal(base_size = 13)
install.packages('forecast')
library(ggplot2)
library(forecast)
data(gtemp_land, package = "astsa")
?gtemp_land
# -----------------------------------------------------------
# 1. Prohlédnutí dat
# -----------------------------------------------------------
start(gtemp_land)
end(gtemp_land)
frequency(gtemp_land)
summary(gtemp_land)
# Rychlý náhled
plot(gtemp_land, main = "Global Land Temperatures", ylab = "Teplota (°C)", xlab = "Rok")
install.packages(astsa)
install.packages('astsa')
install.packages('VGAM')
c(dpois(0:3, lambda_P), 1 - ppois(3, lambda_P))
c(dpois(0:3, 0.027), 1 - ppois(3, 0.027))
c(dpois(0:3, 0.027), 1 - ppois(3, 0.027)) * 42349
m_exp_p
sledkov
(tab <- data.frame(lambda, p, lambda_P)) # sumarizacna tabulka vysledkov
tab <- data.frame(rbind(m_obs, m_exp_p, m_exp_zip))
m_exp_p <- round(dpois(0:4, lambda_P) * M)
library(VGAM)
dzip <- function(x, lambda, p){
px <- p * (x == 0) +
(1 - p) * dpois(x, lambda)
return(px)
}
# test na x = 0, 1, 2 pre λ = 0.89 a p = 0.5
dzip(x = 0:2, lambda = 0.89, p = 0.5)
VGAM::dzipois(x = 0:2, lambda = 0.89, pstr0 = 0.5)
m_exp_p <- round(dpois(0:4, lambda_P) * M)
M
library(VGAM)
dzip <- function(x, lambda, p){
px <- p * (x == 0) +
(1 - p) * dpois(x, lambda)
return(px)
}
# test na x = 0, 1, 2 pre λ = 0.89 a p = 0.5
dzip(x = 0:2, lambda = 0.89, p = 0.5)
VGAM::dzipois(x = 0:2, lambda = 0.89, pstr0 = 0.5)
m_obs <- c(41317, 907, 106, 18, 1) # postupnost m_obs
n <- c(0, 1, 2, 3, 4) # n
observed <- rep(n, m_obs) # vektor pozorovanych pocetnosti: 0, ..., 1, ..., 1, ..., 4
M <- sum(m_obs) # celkovy pocet vsetkych operacii
lambda_P <- sum(n * m_obs) / M # odhad parametra lambda Poissonovho rozdelenia
m <- mean(observed) # odhad strednej hodnoty E[X] ziskany na zaklade vektora pozorovanych pocetnosti
v <- var(observed) # odhad rozptylu Var[X] ziskany na zaklade vektora pozorovanych pocetnosti
p <- (v - m) / (m^2 + v  - m) # odhad parametra p ZIP rozdelenia
lambda <- m + (v / m) - 1 # odhad parametra lambda ZIP rozdelenia
(tab <- data.frame(lambda, p, lambda_P)) # sumarizacna tabulka vysledkov
m_exp_p <- round(dpois(0:4, lambda_P) * M)
px_zip <- VGAM::dzipois(x = 0:4, lambda, p)
m_exp_zip <- round(px_zip * M)
tab <- data.frame(rbind(m_obs, m_exp_p, m_exp_zip))
tab <- data.frame(cbind(tab, apply(tab, 1, sum)),
row.names = c("m_obs", "m_exp_Poiss", "m_exp_ZIP"))
names(tab) <- c(0:4, "sum")
tab
px_zip <- VGAM::dzipois(x = 0:4, lambda, p)
library(VGAM)
dzip <- function(x, lambda, p){
px <- p * (x == 0) +
(1 - p) * dpois(x, lambda)
return(px)
}
# test na x = 0, 1, 2 pre λ = 0.89 a p = 0.5
dzip(x = 0:2, lambda = 0.89, p = 0.5)
VGAM::dzipois(x = 0:2, lambda = 0.89, pstr0 = 0.5)
m_obs <- c(41317, 907, 106, 18, 1) # postupnost m_obs
n <- c(0, 1, 2, 3, 4) # n
observed <- rep(n, m_obs) # vektor pozorovanych pocetnosti: 0, ..., 1, ..., 1, ..., 4
M <- sum(m_obs) # celkovy pocet vsetkych operacii
lambda_P <- sum(n * m_obs) / M # odhad parametra lambda Poissonovho rozdelenia
m <- mean(observed) # odhad strednej hodnoty E[X] ziskany na zaklade vektora pozorovanych pocetnosti
v <- var(observed) # odhad rozptylu Var[X] ziskany na zaklade vektora pozorovanych pocetnosti
p <- (v - m) / (m^2 + v  - m) # odhad parametra p ZIP rozdelenia
lambda <- m + (v / m) - 1 # odhad parametra lambda ZIP rozdelenia
(tab <- data.frame(lambda, p, lambda_P)) # sumarizacna tabulka vysledkov
m_exp_p <- round(dpois(0:4, lambda_P) * M)
px_zip <- VGAM::dzipois(x = 0:4, lambda, p)
m_exp_zip <- round(px_zip * M)
tab <- data.frame(rbind(m_obs, m_exp_p, m_exp_zip))
tab <- data.frame(cbind(tab, apply(tab, 1, sum)),
row.names = c("m_obs", "m_exp_Poiss", "m_exp_ZIP"))
names(tab) <- c(0:4, "sum")
tab
?bquote
?phyper
install.packages(tidy)
install.packages('tidyr')
install.packages('plyr')
matplot (pinchtime, pinch, type = "l", lty = 1, cex=2,
col = 1, lwd = 1,  xlab = "Seconds", ylab = "Force (N)")
matplot(pinchtime, pinch, type = "l", lty = 1, cex=2,
col = 1, lwd = 1,  xlab = "Seconds", ylab = "Force (N)")
?pinch
pinch
#############
# Libraries #
#############
library(tidyr)
library(plyr)
library(ggplot2)
library(fda)
matplot(pinchtime, pinch, type = "l", lty = 1, cex=2,
col = 1, lwd = 1,  xlab = "Seconds", ylab = "Force (N)")
x <- 0:150 #tady dela problemy nechat pinchtime
y <- pinch
rangeval <- range(x)
bbasis <- create.bspline.basis(rangeval = rangeval, norder = 4, breaks = x)
curv.Lfd <- int2Lfd(2)
lambdas <- exp(-10:10)
gcvs <- rep(0, length(lambdas))
for(i in 1:length(lambdas)){
pPar <- fdPar(bbasis, curv.Lfd, lambdas[i])
gcvs[i] <- mean(smooth.basis(x, y, pPar)$gcv)
}
best <- which.min(gcvs)
lambda <- lambdas[best]
pPar <- fdPar(bbasis, curv.Lfd, lambda)
pinchSmooth <- smooth.basis(x, y, pPar) #vyhlazeny fd objekt
plot(pinchSmooth$fd)
pinchfd <- pinchSmooth$fd
pinchPCA <- pca.fd(pinchfd, nharm = 6)
plot(pinchPCA$varprop,type='b')
lambdas <- exp(-6:6)
CVmat <- matrix(0, length(lambdas), 20)
for(i in 1:length(lambdas)){
tfdPar <- fdPar(bbasis, curv.Lfd, lambdas[i])
for(j in 1:20){
tpca <- pca.fd(pinchSmooth$fd[-j], nharm = 2, harmfdPar = tfdPar, centerfns = TRUE)
tpfd <- pinchSmooth$fd[j] - tpca$meanfd
tharmvals <- eval.fd(x, tpca$harmonics)
tpvals <- eval.fd(x, tpfd)
CVmat[i,j] <- mean(lm(tpvals ~ tharmvals - 1)$res^2)
}
}
CV <- apply(CVmat, 1, mean)
plot(CV)
plot(CV, type = 'ů')
plot(CV, type = 'l')
plot(CV, type = 'b')
plot(tpca$harmonics[1:2])
lambdas <- exp(-6:6)
CVmat <- matrix(0, length(lambdas), 20)
for(i in 1:length(lambdas)){
tfdPar <- fdPar(bbasis, curv.Lfd, lambdas[i])
for(j in 1:20){
tpca <- pca.fd(pinchSmooth$fd[-j], nharm = 2, harmfdPar = tfdPar, centerfns = TRUE)
tpfd <- pinchSmooth$fd[j] - tpca$meanfd
tharmvals <- eval.fd(x, tpca$harmonics)
tpvals <- eval.fd(x, tpfd)
CVmat[i,j] <- mean(lm(tpvals ~ tharmvals - 1)$res^2)
}
}
#############
# Libraries #
#############
library(tidyr)
library(plyr)
library(ggplot2)
library(fda)
#######################
# 1. Pinch Force Data #
#######################
# Load the variable **pinch** from the **fda** package.
# The variable pinch contains 20 replications of a subject pinching between their thumb and forefinger.
# For each replicate, the force of the pinch was recorded at 151 time points.
matplot(pinchtime, pinch, type = "l", lty = 1, cex=2,
col = 1, lwd = 1,  xlab = "Seconds", ylab = "Force (N)")
# Smooth the data by B-spline bases with second-derivative penalties and plot the
# result
x <- 0:150 #
y <- pinch
rangeval <- range(x)
bbasis <- create.bspline.basis(rangeval = rangeval, norder = 4, breaks = x)
curv.Lfd <- int2Lfd(2)
lambdas <- exp(-10:10)
gcvs <- rep(0, length(lambdas))
for(i in 1:length(lambdas)){
pPar <- fdPar(bbasis, curv.Lfd, lambdas[i])
gcvs[i] <- mean(smooth.basis(x, y, pPar)$gcv)
}
best <- which.min(gcvs)
lambda <- lambdas[best]
pPar <- fdPar(bbasis, curv.Lfd, lambda)
pinchSmooth <- smooth.basis(x, y, pPar) #vyhlazeny fd objekt
plot(pinchSmooth$fd)
# Conduct a principal components analysis of these data. How many components do
# you need to recover 90% of the variation? Do the components appear
# satisfactory? Plot the principal components.
pinchfd <- pinchSmooth$fd
pinchPCA <- pca.fd(pinchfd, nharm = 6)
# Variability
plot(pinchPCA$varprop,type='b') # # first 2 components contain almost 90% of all variability
# Plotting principal components
plot(pinchPCA$varprop,type='b')
plot(pinchPCA$harmonics[1:2])
# Try a smoothed PCA analysis. Choose the smoothing parameter by cross-validation. Plot the cross-validation curve.
lambdas <- exp(-6:6)
CVmat <- matrix(0, length(lambdas), 20)
for(i in 1:length(lambdas)){
tfdPar <- fdPar(bbasis, curv.Lfd, lambdas[i])
for(j in 1:20){
tpca <- pca.fd(pinchSmooth$fd[-j], nharm = 2, harmfdPar = tfdPar, centerfns = TRUE)
tpfd <- pinchSmooth$fd[j] - tpca$meanfd
tharmvals <- eval.fd(x, tpca$harmonics)
tpvals <- eval.fd(x, tpfd)
CVmat[i,j] <- mean(lm(tpvals ~ tharmvals - 1)$res^2)
}
}
install.packages('extraDistr')
install.packages('scatterplot3d')
- Generate $1\,000$ random functions
Plot the estimates $\widehat\beta(t)$ and compare it with the original $\beta(t)$.
## **Betas Comparison**
## **Betas Comparison**
install.packages("MVN")
?install.packages
install.packages("MVN")
install.packages("MVN", verbose =T)
library(MVN)
MVN::mvn(data_F, mvnTest = 'royston')$multivariateNormality
MVN::mvn(data_F, mvnTest = 'mardia')$multivariateNormality
install.packages("MVN")
# vynutit instalaci binárek a nikdy nekompilovat ze zdroje
options(install.packages.check.source = "no")
install.packages(c("ggplot2","cowplot","doBy","pbkrtest","car","MVN"), type = "binary")
install.packages("remotes")
remotes::install_version("ggplot2", version = "3.5.1", type = "binary")
install.packages("MVN")
.libPaths()
install.packages("MVN", lib = "C:/Users/cerve/AppData/Local/R/win-library/4.2")
.libPaths()
install.packages("MVN", lib = ""C:/Program Files/R/R-4.2.2/library"")
install.packages("MVN", lib = C:/Program Files/R/R-4.2.2/library")
install.packages("MVN", lib = "C:/Program Files/R/R-4.2.2/library")
library(MVN)
install.packages('gsl')
install.packages("MVN")
installed.packages()
install.packages("MVN")
library(MVN)
# a) nenuť zdrojové balíky
options(install.packages.check.source = "no")
# b) nainstaluj přímo binární MVN 5.9
install.packages("MVN", type = "binary")
library(MVN)
install.packages("installr")
library(installr)
updateR()
install.packages('fda')
## (b)
setwd("C:/Users/cerve/Desktop/N-MSTAT/3. Semestr/Časovky I/casovky_proj")
library(dplyr)
```{r}
# Načtení datasetu
data <- read.csv("MLTollsStackOverflow.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
View(data)
data$month <- as.Date(data$DATE)
# data$month <- as.Date(data$DATE)
head(data)
# Načtení potřebných balíčků
if (!require(forecast)) install.packages("forecast", repos = "https://cloud.r-project.org")
summary(data[, c("month", "python", "r")])
range(data$ym)     # od kdy do kdy máme data
r_ts <- ts(so$r,
start = c(2009, 1),
frequency = 12)
r_ts <- ts(data$r,
start = c(2009, 1),
frequency = 12)
python_ts
r_ts <- ts(data$r,
start = c(2009, 1),
frequency = 12)
python_ts
summary(python_ts)
library(tseries)
```{r}
# převod např. "09-Jan" -> yearmon objekt (2009-01)
data$ym <- as.yearmon(data$month, format = "%y-%b")
if (!require(zoo)) install.packages("zoo")
if (!require(readr)) install.packages("readr", repos = "https://cloud.r-project.org")
if (!require(readr)) install.packages("readr", repos = "https://cloud.r-project.org")
library(readr)
library(zoo)
library(forecast)
library(tseries)
library(ggplot2)
library(dplyr)
# Načtení datasetu
data <- read_csv("MLTollsStackOverflow.csv")
# Načtení datasetu
data <- read_csv("MLTollsStackOverflow.csv")
summary(data[, c("month", "python", "r")])
```{r}
# převod např. "09-Jan" -> yearmon objekt (2009-01)
data$ym <- as.yearmon(data$month, format = "%y-%b")
# pro jistotu seřadíme podle času
data <- data[order(data$ym), ]
# kontrola, že jsou měsíce po sobě bez děr
diff_ym <- diff(as.numeric(data$ym))
table(diff_ym)   # ideálně jen hodnota 1
range(data$ym)     # od kdy do kdy máme data
```{r}
python_ts <- ts(data$python,
start = c(2009, 1),
frequency = 12)
r_ts <- ts(data$r,
start = c(2009, 1),
frequency = 12)
par(mfrow = c(2,1))
plot(python_ts,
main = "StackOverflow: dotazy k Pythonu",
ylab = "počet dotazů za měsíc",
xlab = "rok")
plot(r_ts,
main = "StackOverflow: dotazy k R",
ylab = "počet dotazů za měsíc",
xlab = "rok")
View(data)
data$ym
# Načtení datasetu
data <- read_csv("MLTollsStackOverflow.csv")
View(data)
#| label: knihovny
#| echo: true
# Načtení potřebných balíčků
if (!require(forecast)) install.packages("forecast", repos = "https://cloud.r-project.org")
if (!require(zoo)) install.packages("zoo")
if (!require(readr)) install.packages("readr", repos = "https://cloud.r-project.org")
library(readr)
library(zoo)
library(forecast)
library(tseries)
library(ggplot2)
library(dplyr)
#| label: data
#| echo: true
# Načtení datasetu
data <- read_csv("MLTollsStackOverflow.csv")
head(data[c("month", "python", "r")])
#| label: popis-dat
#| echo: true
# Popisné statistiky
summary(data[, c("month", "python", "r")])
#| label: vyzkum
#| echo: true
# Vytvoření časové řady: Python
python_ts <- ts(data$python,
start = c(2009, 1),
frequency = 12)
# Vytvoření časové řady: R
r_ts <- ts(data$r,
start = c(2009, 1),
frequency = 12)
par(mfrow = c(2,1))
# Graf: Python
plot(python_ts,
main = "StackOverflow: dotazy k Pythonu",
ylab = "počet dotazů za měsíc",
xlab = "rok")
# Graf: R
plot(r_ts,
main = "StackOverflow: dotazy k R",
ylab = "počet dotazů za měsíc",
xlab = "rok")
# Společný graf
par(mfrow = c(1,1))
ts.plot(cbind(python_ts, r_ts),
col = c("blue", "red"),
lty = 1:2,
main = "Python vs R",
ylab = "Počet dotazů za měsíc")
legend("topleft",
legend = c("Python", "R"),
col = c("blue", "red"),
lty = 1:2,
bty = "n")
#| label: vyzkum_3
#| echo: true
# Additivní dekompozice
## Python
decomp_python <- decompose(python_ts, type = "additive")
plot(decomp_python)
## R
stl_r <- stl(r_ts, s.window = "periodic")
plot(stl_r)
#| label: vyzkum_2
#| echo: true
# STL dekompozice
## Python
stl_python <- stl(python_ts, s.window = "periodic")
plot(stl_python)
## R
stl_r <- stl(r_ts, s.window = "periodic")
plot(stl_r)
#| label: transformace
#| echo: true
# log_ts <- log(ts_data)
# sqrt_ts <- sqrt(ts_data)
# par(mfrow = c(3,1))
# plot(ts_data, main = "Původní řada")
# plot(log_ts, main = "Log transformace")
# plot(sqrt_ts, main = "Odmocnina")
#| label: stacionarita
#| echo: true
#| label: stacionarita
#| echo: true
library(tseries)
# ADF test pro původní řady
adf_python <- adf.test(python_ts)
adf_r      <- adf.test(r_ts)
adf_python
adf_r
# ADF test pro diferencované řady
adf_python_diff <- adf.test(diff(python_ts))
adf_r_diff      <- adf.test(diff(r_ts))
adf_python_diff
adf_r_diff
#| label: acf-pacf_python
#| echo: true
par(mfrow = c(2,2))
acf(python_ts, main = "ACF – Python")
pacf(python_ts, main = "PACF – Python")
acf(diff(python_ts), main = "ACF – diff(Python)")
pacf(diff(python_ts), main = "PACF – diff(Python)")
#| label: acf-pacf_R
#| echo: true
par(mfrow = c(2,2))
acf(r_ts, main = "ACF – R")
pacf(r_ts, main = "PACF – R")
acf(diff(r_ts), main = "ACF – diff(R)")
pacf(diff(r_ts), main = "PACF – diff(R)")
#| label: acf-pacf_R
#| echo: true
# acf(ts_data)
# pacf(ts_data)
#| label: modely-vyber
#| echo: true
# auto.arima(ts_data)
# sarima_model <- auto.arima(ts_data, seasonal = TRUE)
#| label: modely-odhad
#| echo: true
# ar_model <- ar(ts_data)
# arma_model <- arima(ts_data, order = c(1,0,1))
# sarima_model <- arima(ts_data, order = c(1,1,1), seasonal = c(1,1,1))
#| label: diagnostika
#| echo: true
# checkresiduals(arma_model)
# tsdiag(arma_model)
#| label: predikce
#| echo: true
# forecast_arma <- forecast(arma_model, h = 12)
# autoplot(forecast_arma)
?adf.test
box_python
#| label: stacionarita_python
#| echo: true
box_python <- box.test(python_ts, type = "Ljung-Box")
install.packages("LSTS")
?diff
