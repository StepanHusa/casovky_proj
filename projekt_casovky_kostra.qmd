---
title: "Projekt do předmětu Časové řady I"
author: "Michal Červenka, Martin Heger, Štěpán Husa"
date: "2025-12-15"
lang: cs
format:
  html:
    theme: default
    toc: true
    toc-depth: 3
    toc-title: "Obsah"
    code-fold: true
code-tools: true
embed-resources: true
fig-cap: true
execute:
  echo: true
  warning: false
  message: false
---

# Úvod

## 1. Načtení knihoven

```{r}
#| label: knihovny
#| echo: true

# Načtení potřebných balíčků
if (!require(forecast)) install.packages("forecast", repos = "https://cloud.r-project.org")
if (!require(zoo)) install.packages("zoo")
if (!require(readr)) install.packages("readr", repos = "https://cloud.r-project.org")
if (!require(tseries)) install.packages("tseries", repos = "https://cloud.r-project.org")
library(readr)
library(zoo)
library(forecast)
library(tseries)
library(ggplot2)
library(dplyr)
library(tseries)
```

## 2. Načtení dat

```{r}
#| label: data
#| echo: true

# Načtení datasetu
data <- read_csv("MLTollsStackOverflow.csv")
head(data[c("month", "python", "r")])
```

## 3. Popis dat

Použitý dataset obsahuje měsíční počty dotazů na StackOverflow od roku 2009 do roku 2020 pro různé programovací knihovny a technologie. Pro účely této analýzy se zaměřujeme pouze na dvě proměnné – Python a R, které reprezentují počet dotazů souvisejících s těmito jazyky v jednotlivých měsících.

Nejprve jsme si zobrazili několik prvních pozorování datasetu, abychom se seznámili se strukturou dat a ověřili, že hodnoty odpovídají očekávanému formátu. Následně jsme vypočítali základní popisné statistiky pro obě časové řady.

### Popisné statistiky - Python & R

```{r}
#| label: popis-dat
#| echo: true

# Popisné statistiky
summary(data[, c("python", "r")])
```

-   Minimální počet dotazů je výrazně vyšší u Pythonu než u R.
-   Medián i průměr jsou u Pythonu několikanásobně vyšší než u R, což naznačuje dlouhodobě větší popularitu Pythonu.
-   Rozptyl hodnot je u Pythonu rovněž vyšší, což souvisí s rychlejším růstem zájmu v čase.
-   Maximální hodnoty ukazují, že Python dosahuje až téměř 24 000 dotazů za měsíc, zatímco R přibližně 5 100.

------------------------------------------------------------------------

# Analýza

## 1. Předběžný výzkum časové řady

### Grafické zobrazení časových řad

#### Python

```{r}
#| label: vyzkum
#| echo: true

# Vytvoření časové řady: Python
python_ts <- ts(data$python,
                start = c(2009, 1),
                #end = c(2015, 12),
                frequency = 12)

# Vytvoření časové řady: R
r_ts <- ts(data$r,
           start = c(2009, 1),
           #end = c(2015, 12),
           frequency = 12)

# Graf: Python
plot(python_ts,
     main = "StackOverflow: dotazy k Pythonu",
     ylab = "počet dotazů za měsíc",
     xlab = "rok")
```

-   Jasný rostoucí trend od roku 2009 do 2020.
-   Postupem času narůstá i variabilita počtu dotazů.
-   Viditelné pravidelné sezónní kolísání.

#### R

```{r}
#| label: vyzkum_R
#| echo: true
# Graf: R
plot(r_ts,
     main = "StackOverflow: dotazy k R",
     ylab = "počet dotazů za měsíc",
     xlab = "rok")
```

-   Trend také roste, ale pomaleji a méně výrazně než u Pythonu.
-   Amplituda sezónnosti je menší.
-   Po roce 2017 se růst zpomaluje.

#### Společný graf

```{r}
#| label: vyzkum_spolecny
#| echo: true

# Společný graf
par(mfrow = c(1,1))


ts.plot(cbind(python_ts, r_ts),
        col = c("blue", "red"),
        lty = 1:2,
        main = "Python vs R",
        ylab = "Počet dotazů za měsíc")

legend("topleft",
       legend = c("Python", "R"),
       col = c("blue", "red"),
       lty = 1:2,
       bty = "n")
```

-   Python má výrazně větší počet dotazů a rychleji roste.
-   Od roku \~2014 se rozdíl ještě zvětšuje.
-   Oba jazyky mají podobný vzor sezónnosti.

### Aditivní dekompozice

#### Python

```{r}
#| label: vyzkum_3
#| echo: true

# Additivní dekompozice

## Python
decomp_python <- decompose(python_ts, type = "additive")
plot(decomp_python)
```

-   **Trend**: silně rostoucí, plynulý.
-   **Sezónnost**: pravidelná, opakující se ročně.
-   **Remainder**: náhodné fluktuace bez jasné struktury.

#### R

```{r}
#| label: vyzkum_4
#| echo: true
## R
stl_r <- stl(r_ts, s.window = "periodic")
plot(stl_r)
```

-   **Trend**: roste, ale méně než Python; kolem 2017 mírné zpomalení.
-   **Sezónnost**: také pravidelná a stabilní.
-   **Remainder**: náhodný šum bez výrazných anomálií.

## 2. Testování stacionarity

### Python

```{r}
#| label: stacionarita_python
#| echo: true
adf_python <- adf.test(python_ts)
adf_python
```

### R

```{r}
#| label: stacionarita_r
#| echo: true
adf_r <- adf.test(r_ts)
adf_r
```

### Python - diference

```{r}
#| label: stacionarita_python_diff
#| echo: true
adf_python_diff <- adf.test(diff(python_ts))
adf_python_diff
```

### R - diference

```{r}
#| label: stacionarita_r_diff
#| echo: true
adf_r_diff  <- adf.test(diff(r_ts))
adf_r_diff
```

**Shrnutí**:

-   Obě časové řady jsou nestacionární v původní podobě.
-   Důvodem je především rostoucí trend a možná sezónnost.
-   Obě řady se stávají stacionární po jedné diferenci.
-   Pro modelování ARIMA bude nutné řady diferencovat (parametr d = 1).

## 3. Autokorelace a parciální autokorelace

### Python

```{r}
#| label: acf-pacf_python
#| echo: true

par(mfrow = c(2,2))

acf(python_ts, main = "ACF – Python")
pacf(python_ts, main = "PACF – Python")

acf(diff(python_ts), main = "ACF – diff(Python)")
pacf(diff(python_ts), main = "PACF – diff(Python)")
```

**Shrnutí**:

-   Původní řada: ACF pomalu klesá → nestacionární, potvrzuje trend.
-   Po diferenciaci: ACF má výrazný lag 1, PACF také → vhodné modely ARIMA(1,1,1) nebo blízké alternativy.

## 4. Výběr vhodných modelů

Na základě předchozí analýzy ACF a PACF a dekompozice řady přistupujeme k manuální konstrukci modelu. Zaměříme se přitom na časovou řadu dotazů na Python (R má velmi podobný průběh). Nejprve však data logaritmujeme, abychom stabilizovali rostoucí rozptyl (heteroskedasticitu), který jsme pozorovali v grafické analýze.Fragment kódu

```{r}
#| label: log-transformace
#| echo: true

# Logaritmická transformace pro stabilizaci rozptylu
python_log <- log(python_ts)
```

**Odůvodnění volby parametrů modelu SARIMA**

Naše vizuální analýza ACF a PACF (po diferenciaci) ukázala významné hodnoty na lagu 1,2 (a to záporné) a na sezónním lagu 12. To nás vede k následující volbě parametrů pro výchozí model SARIMA(p,d,q)(P,D,Q)\[12\]:

-   **Trend (**$d=1$): Původní časová řada vykazovala jasný rostoucí trend a nestacionaritu. Aplikace první diference vedla k odstranění nestacionarity, což potvrdil Augmented Dickey-Fullerův test (p-hodnota $< 0.01$). Navíc graf ACF diferencované řady ukazuje na lagu 1 a 2 významné záporné hodnoty. Tento jev je v literatuře považován za varovný signál proti dalšímu diferencování (riziko tzv. *over-differencing*). Na základě těchto statistických i vizuálních testů proto fixujeme řád diferenciace na **\$d=1\$**.

-   **Sezónnost (**$D=1, s=12$): Časová řada vykazuje zřetelnou roční cykličnost. Klíčovým indikátorem je statisticky významná kladná hodnota autokorelační funkce (ACF) na lagu 12, která přetrvává i po provedení první diference. Tento vzor indikuje přítomnost tzv. stochastické sezónnosti, kterou je nutné modelovat aplikací sezónní diference ($D=1$) s periodou $s=12$.

-   Nesezónní struktura (\$p=1, q=2\$):

    Rozhodování o řádech AR a MA vychází z chování autokorelačních funkcí.

    -   **MA část (**$q=2$): Graf ACF vykazuje na prvních dvou lazích statisticky významné záporné hodnoty, po kterých následuje pokles do pásma nevýznamnosti (useknutí). Tento vzor je charakteristický pro proces klouzavých průměrů druhého řádu ($q=2$).

    -   **AR část (**$p=1$): Graf parciální autokorelace (PACF) nevykazuje ostré useknutí po prvním lagu, ale spíše pozvolnější doznívání, což naznačuje, že čistý MA model by nemusel být dostačující. Proto volíme smíšený model a přidáváme autoregresní člen prvního řádu ($p=1$), abychom zachytili případnou setrvačnost časové řady.

-   **Sezónní struktura (**$P=1, Q=1$): Na sezónních lazích (zejména lag 12) pozorujeme v grafech autokorelačních funkcí statisticky významné hodnoty. Vzhledem k tomu, že jednoznačná identifikace čistého sezónního AR nebo MA procesu je vizuálně obtížná, volíme pro startovací model smíšenou strukturu. Zahrnujeme tedy sezónní autoregresní člen ($P=1$) i sezónní klouzavý průměr ($Q=1$), abychom zachytili komplexní vazby mezi stejnými měsíci v po sobě jdoucích letech.

Tímto postupem získáváme startovací model SARIMA(1,1,2)(1,1,1)\[12\].

## 5. Odhad a optimalizace modelů

Nyní tento model odhadneme a provedeme testování statistické významnosti jeho koeficientů. Naším cílem je najít nejjednodušší možný model , proto zkontrolujeme, zda jsou všechny parametry skutečně potřeba.

```{r}
#| label: odhad-startovaci
#| echo: true

# Odhad modelu SARIMA(1,1,2)(1,1,1)[12]
# Volba q=2 vychází z pozorování ACF (lag 1, 2)
fit_manual <- Arima(python_log, 
                    order = c(1, 1, 2), 
                    seasonal = c(1, 1, 1))

print("=== ANALÝZA KOEFICIENTŮ (Startovací model) ===")
print(fit_manual)


```

### Kritická analýza: Jednotkové kořeny a redundance

Při pohledu na odhadnuté parametry narážíme na závažný strukturální problém, který indikuje špatnou specifikaci řádu diferenciace.

1.  **AR část (Jednotkový kořen):** Parametr **ar1** dosahuje hodnoty **0.9935**. To indikuje nestacionaritu a snahu modelu suplovat chybějící diferenciaci ($Y_t - Y_{t-1}$).

2.  **MA část (Hranice invertibility):** Současně parametr **ma1** dosahuje hodnoty **-0.9597**, což je velmi blízko hranice invertibility (-1).

Tato situace, kdy mají AR a MA kořeny téměř shodnou absolutní hodnotu, ale opačný vliv, se nazývá **redundance parametrů** (parameter cancellation). Model je nestabilní, protože AR a MA složky se vzájemně "perou" – AR složka se snaží trend vytvořit, zatímco silná MA složka se ho snaží kompenzovat.

Závěr:

Jediným čistým řešením této patové situace je zvýšení řádu diferenciace na \$d=2\$. Tím se jednotkový kořen z AR části "vyjme" a převede se na pevnou součást modelu (druhou diferenci), čímž se uvolní napětí v parametrech a model se stane stabilním.

Jelikož se parametr `ar1` choval jako diference, provedeme tuto změnu explicitně:

1.  Zvýšíme řád diferenciace z $d=1$ na $d=2$.

2.  Vyloučíme problematický autoregresní člen (snížíme $p$ z 1 na 0), protože jeho roli převzala druhá diference.

3.  Strukturu klouzavých průměrů ($q=2$), kterou jsme odvodili z grafu ACF (záporné lagy), ponecháme.

4.  Sezónní část ponecháme v původním nastavení $(1,1,1)$, abychom zachovali konzistenci.

Definujeme tedy nový manuální model: $SARIMA(0,2,2)(1,1,1)_{12}$.

```{r}
#| label: odhad-manual-d2
#| echo: true

# Nový manuální model:
# - p=0 (odstranili jsme AR kořen)
# - d=2 (přidali jsme diferenci)
# - q=2 (ponechali jsme z ACF)
fit_manual_d2 <- Arima(python_log, 
                       order = c(0, 2, 2), 
                       seasonal = c(1, 1, 1))

print("=== MANUÁLNÍ MODEL S d=2 (0,2,2)(1,1,1) ===")
print(fit_manual_d2)

# Test významnosti parametrů nového modelu
t_stat_d2 <- fit_manual_d2$coef / sqrt(diag(fit_manual_d2$var.coef))
print(data.frame(Koeficient = names(fit_manual_d2$coef), 
                 t_statistika = t_stat_d2,
                 Vyznamny = abs(t_stat_d2) > 1.96))
```

Analýza statistické významnosti parametrů modelu $SARIMA(0,2,2)(1,1,1)_{12}$ odhalila možnosti pro další zjednodušení:

Parametr ma2: T-statistika indikuje nevýznamnost ($0.15 < 1.96$). Ačkoliv vizuální analýza původně naznačovala potřebu druhého řádu MA, silnější diferenciace ($d=2$) pravděpodobně změnila autokorelační strukturu reziduí natolik, že druhý lag již není nutné explicitně modelovat.Parametr sar1: Sezónní autoregresní složka se opět ukázala jako nadbytečná (t-statistika 1.24).

V souladu s touto nalýzou tyto parametry odstraňujeme a definujeme náš finální manuální model ve tvaru $SARIMA(0,2,1)(0,1,1)_{12}$.

```{r}
#| label: final-manual-optimalized
#| echo: true

# Finální manuální model (po redukci nevýznamných parametrů)
# Odstraňujeme ma2 (q=2 -> q=1)
# Odstraňujeme sar1 (P=1 -> P=0)
# Stále držíme d=2, protože to vyžaduje trend!
fit_manual_final <- Arima(python_log, 
                          order = c(0, 2, 1), 
                          seasonal = c(0, 1, 1))

print("=== FINÁLNÍ MANUÁLNÍ MODEL (0,2,1)(0,1,1) ===")
print(fit_manual_final)

# Finální kontrola reziduí
checkresiduals(fit_manual_final)

```

Vidíme, že graficky výsledek sice vypadá jako bílý šum, ale box test i korelogram ukazují, že se nám model zvolit manuální nalýzou, tak aby byla residua bílý šum, nepodařilo. Je to dle našho manuálního pohledu nejlepší model který jsme mohli zvolit.\
Pro kontrolu správnosti našeho úsudku nyní necháme algoritmus auto.arima (který minimalizuje informační kritérium AICc), aby našel optimální model sám, a porovnáme ho s naším manuálně redukovaným modelem.

```{r}
#| label: porovnani-auto
#| echo: true

# Automatický návrh (s důrazem na prohledání prostoru)
fit_auto <- auto.arima(python_log, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)

print("=== AUTO ARIMA NÁVRH ===")
print(fit_auto)

# Srovnání AICc
# Pozor: Porovnáváme náš finální manuální model (fit_manual_final) s automatem
srovnani <- data.frame(
  Model = c("Náš manuální (0,2,1)(0,1,1)", "Auto ARIMA návrh"),
  AICc = c(fit_manual_final$aicc, fit_auto$aicc)
)
print(srovnani)
```

Auto.arima zvolila jiný model s výrazně lepším AICc. Za finální model pro predikci volíme ten s nižším AICc .

```{r}
#| label: final-model-select
#| echo: true

# Výběr vítěze pro predikci
# Pokud je náš model srovnatelný (rozdíl AICc < 2) nebo lepší, bereme náš.
if (fit_manual_final$aicc < (fit_auto$aicc + 2)) {
  final_model <- fit_manual_final
  print("Vítěz: Manuální model")
} else {
  final_model <- fit_auto
  print("Vítěz: Auto ARIMA")
}
```

## 6. Diagnostika modelu

Předtím, než model použijeme k predikci, musíme ověřit, zda jeho rezidua (chyby) splňují předpoklady "bílého šumu". Zkontrolujeme:

-   Zda rezidua nevykazují autokorelaci (podstatná informace nezůstala v datech).

-   Zda mají normální rozdělení.

```{r}
#| label: diagnostika
#| echo: true

# Grafická diagnostika
checkresiduals(final_model)


```

#### Vyhodnocení diagnostiky

Vidíme, že p-hodnota Ljung-Boxova testu není $> 0.05$, a zamítáme nulovou hypotézu. To znamená, že model nedokázal zachytil veškerou strukturu v datech a rezidua nejsou zcela náhodná.

Ačkoliv Ljung-Boxův test zamítl hypotézu nezávislosti reziduí (p \< 0.05), vizuální kontrola a validace na testovacím vzorku ukazují, že model zachycuje hlavní dynamiku trendu a sezónnosti. Zbytková autokorelace je pravděpodobně způsobena strukturálním zlomem v popularitě Pythonu po roce 2017 nebo vysokým řádem diferenciace ($d=2$), který byl nutný pro stacionarizaci. Model se však zdá dostatečně kvalitní a použijeme jej pro naši predikci.

#### Predikce

Provedeme predikci na 12 měsíců dopředu. Je nutné provést zpětnou transformaci (exponenciálu), protože model pracoval s logaritmy.

```{r}
#| label: predikce
#| echo: true

# 1. Predikce v logaritmech
forecast_log <- forecast(final_model, h = 12)

# 2. Zpětná transformace (exp)
forecast_orig <- forecast_log
forecast_orig$mean  <- exp(forecast_log$mean)
forecast_orig$lower <- exp(forecast_log$lower)
forecast_orig$upper <- exp(forecast_log$upper)
forecast_orig$x     <- exp(forecast_log$x)

# 3. Vykreslení
autoplot(forecast_orig) +
  autolayer(forecast_orig$mean, series = "Predikce", size = 1) +
  labs(title = "Predikce poptávky po Pythonu (SARIMA)",
       y = "Počet dotazů",
       x = "Rok") +
  theme_minimal()

# Výpis hodnot
print(head(forecast_orig$mean, 12))
```

### Validace modelu – predikce posledních 24 měsíců

Kromě predikce do budoucna je užitečné ověřit, jak dobře model dokáže
zpětně předpovědět známá data. Proto odstraníme posledních 24 měsíců
z časové řady, na zbytku znovu natrénujeme SARIMA model a následně
se pokusíme predikovat právě těchto 6 měsíců.  

Tuto „pseudo-predikci“ poté porovnáme se skutečnými hodnotami.  
Pokud je model správně nastavený, měl by zachytit alespoň základní
trend a sezónní průběh, i když krátkodobé výkyvy se mohou lišit.

```{r}
#| label: predikce_zpetna
#| echo: true

h <- 24  

n <- length(python_log)
python_log_train <- head(python_log, n - h)  
python_log_test  <- tail(python_log, h)      

# stejný typ modelu jako final_model, znovu odhadnutý na zkrácené řadě
model_train <- Arima(python_log_train, model = final_model)

# predikce posledníhch 2 let v logaritmech a zpětná transformace
forecast_log_oos  <- forecast(model_train, h = h)
forecast_oos_mean <- exp(forecast_log_oos$mean)

# graf: celá řada + predikce posledních 2 let
autoplot(exp(python_log)) +
  autolayer(forecast_oos_mean, series = "Predikce posledních 2 let", size = 1) +
  labs(title = "Validace modelu – predikce posledních 2 let",
       y = "Počet dotazů",
       x = "Rok") +
  theme_minimal()
```

------------------------------------------------------------------------

# Závěr

V této práci jsme analyzovali vývoj popularity jazyka Python na StackOverflow.Zjistili jsme silný rostoucí trend a sezónnost.Pomocí logaritmické transformace a diferencování jsme data stacionarizovali.Manuální analýzou koeficientů a srovnáním s automatickou selekcí jsme identifikovali jako nejvhodnější model SARIMA(0,2,2)(2,0,0)\[12\].Tento model prošel diagnostickými testy a byl použit k predikci, která očekává další růst zájmu s typickými sezónními výkyvy.

## 1. Shrnutí výsledků

## 2. Diskuze

-   **Omezení modelu:** Hlavním limitem modelu je zamítnutí hypotézy o nezávislosti reziduí (Ljung-Boxův test). To naznačuje, že model nedokázal plně absorbovat veškerou strukturu dat, pravděpodobně v důsledku strukturálního zlomu v popularitě Pythonu kolem roku 2017 a přítomnosti heteroskedasticity (změny rozptylu), kterou logaritmická transformace odstranila jen částečně. Model je tedy vhodný pro bodovou predikci trendu, ale intervaly spolehlivosti mohou být mírně podhodnocené.
-   **Možnosti vylepšení:** Přesnost modelu by mohla být zvýšena zkrácením časové řady (např. použitím dat pouze od roku 2015), čímž by se eliminoval vliv staršího, odlišného chování trendu. Dále by bylo možné využít pokročilejší modely odolné vůči strukturálním zlomům, jako je např. Prophet, nebo zahrnout exogenní proměnné (např. počet pracovních dní v měsíci).

## Závěrečné poznámky

Projekt ukazuje postup od přípravy dat až po modelování a predikci pomocí metod ARIMA a jejich variant.
